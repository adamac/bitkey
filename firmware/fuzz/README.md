# Fuzzing

This directory contains code and resources to assist with fuzzing.

## How to fuzz

Currently, [libfuzzer](https://llvm.org/docs/LibFuzzer.html) is integrated into the build system.

`libfuzzer` is an in-process coverage-guided fuzzer designed to fuzz libraries. See [getting started](https://llvm.org/docs/LibFuzzer.html#fuzz-target) for more.

To add a new fuzz target, create a file ending with `_fuzz.cc` (do use C++) and make a Meson build target:
```
foo_fuzz = executable('foo-fuzz',
  'src/foo_fuzz.cc',
  cpp_args : fuzz_args,  # fuzz_args is defined in fuzz/meson.build
  link_args : fuzz_args,
  dependencies : [foo_dep, fuzzed_data_provider_dep],
)
```

Build with `inv fuzz`, and run your target out of `build`.

Building with libfuzzer requires `libclang_rt.fuzzer_osx.a` (on MacOS), which is not included in Apple's LLVM. To get around this,
install LLVM with `brew` and run `inv` like so:

```
# On Apple Silicon
CC=/opt/homebrew/opt/llvm@14/bin/clang CXX=/opt/homebrew/opt/llvm@14/bin/clang inv clean fuzz

# On Rosetta 2
CC=/usr/local/opt/llvm@14/bin/clang CXX=/usr/local/opt/llvm@14/bin/clang inv clean fuzz
```

Note that because `libfuzzer` is in-process, if your program aborts or exit on malformed input, the fuzzing engine will die too.
This is different from approaches taken by e.g. AFL. In general, `libfuzzer` is meant to fuzz libraries which don't kill the process.

`libfuzzer` will write crashes to disk as `crash-<hex-encoded-string>`.
You can feed these files back into the program: `./fuzz-target crash-22fb06955f938cc21720b6f49919a20dc95dd9c0` to reproduce the crash.

## Fuzzing tips

### What to fuzz

You can pass `-jobs=n` to parallelize the fuzzer.

Try to fuzz:

* Narrow APIs like single functions, or a small collection of functions. Think of it like a unit test.

Make sure that:

* Your program doesn't exit / abort on inputs. If it does, and _has_ to, try to work around this when the target is getting fuzzed with #defines.

Try to avoid:

* Functions which require magic numbers to proceed. These can mess up the fuzzing engine. Try to remove these conditions with #defines, or set up your API in your _fuzz test with the right conditions.
* Randomness. Your crashes may not reproduce, and this can mess up the fuzzer.
* Slow code.

### Handling libfuzzer inputs

`libfuzzer` gives you a stream of "random" bytes generated by the fuzzer -- but you have to convert that stream into something meaningful
to provide to your program. [See this writeup on how to handle this](https://github.com/google/fuzzing/blob/master/docs/split-inputs.md) --
but the tl;dr is link against `fuzzed_data_provider_dep` and use that.

### The API problem

Fuzzing functions like `void do_complicated_parsing(uint8_t *buf, size_t len)` is very easy. Fuzzing complex and _stateful_ APIs is not.
Dealing with this problem requires some work, but is doable -- [the problem and solution is described here](https://youtu.be/xzG0pLM4Q64?t=472).

Full talk: [Modern Source Fuzzing](https://www.youtube.com/watch?v=xzG0pLM4Q64)
