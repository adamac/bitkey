package build.wallet.statemachine.data.recovery.inprogress

import build.wallet.bitkey.app.AppGlobalAuthPublicKey
import build.wallet.bitkey.f8e.FullAccountId
import build.wallet.bitkey.factor.PhysicalFactor
import build.wallet.bitkey.keybox.Keybox
import build.wallet.bitkey.keybox.KeyboxConfig
import build.wallet.bitkey.socrec.TrustedContact
import build.wallet.cloud.backup.csek.SealedCsek
import build.wallet.f8e.auth.HwFactorProofOfPossession
import build.wallet.nfc.transaction.NfcTransaction
import build.wallet.nfc.transaction.SignChallengeAndCsek.SignedChallengeAndCsek
import build.wallet.statemachine.data.recovery.sweep.SweepData
import build.wallet.statemachine.data.recovery.verification.RecoveryNotificationVerificationData
import build.wallet.time.durationProgress
import build.wallet.time.nonNegativeDurationBetween
import kotlinx.datetime.Clock
import kotlinx.datetime.Instant
import kotlin.time.Duration

/**
 * Undergoing Delay & Notify recovery for lost physical factor (app or hardware).
 */
sealed interface RecoveryInProgressData {
  /**
   * Indicates that there is an ongoing recovery in progress and we are waiting for delay
   * before completing the recovery.
   *
   * @property factorToRecover physical factor that is being recovered.
   * @property delayPeriodStartTime timestamp of when Delay period has started.
   * @property delayPeriodEndTime timestamp of when Delay period is supposed to end and when we
   * should be ready to complete recovery.
   */
  data class WaitingForRecoveryDelayPeriodData(
    val factorToRecover: PhysicalFactor,
    val delayPeriodStartTime: Instant,
    val delayPeriodEndTime: Instant,
    val retryCloudRecovery: (() -> Unit)?,
    val cancel: () -> Unit,
  ) : RecoveryInProgressData {
    fun delayPeriodProgress(clock: Clock): Float =
      durationProgress(
        now = clock.now(),
        startTime = delayPeriodStartTime,
        endTime = delayPeriodEndTime
      )

    fun remainingDelayPeriod(clock: Clock): Duration =
      nonNegativeDurationBetween(
        startTime = clock.now(),
        endTime = delayPeriodEndTime
      )
  }

  data class AwaitingProofOfPossessionForCancellationData(
    val appAuthKey: AppGlobalAuthPublicKey,
    val addHardwareProofOfPossession: (HwFactorProofOfPossession) -> Unit,
    val rollback: () -> Unit,
    val fullAccountId: FullAccountId,
  ) : RecoveryInProgressData

  /** Cancelling recovery. */
  data class CancellingData(
    val recoveredFactor: PhysicalFactor,
  ) : RecoveryInProgressData

  /**
   * [AwaitingProofOfPossessionForCancellationData] failed.
   */
  data class FailedToCancelRecoveryData(
    val recoveredFactor: PhysicalFactor,
    val isNetworkError: Boolean,
    val onAcknowledge: () -> Unit,
  ) : RecoveryInProgressData

  /**
   * Indicates that we are in the notification verification flow because additional
   * verification was requested by the server for cancellation.
   */
  data class VerifyingNotificationCommsForCancellationData(
    val data: RecoveryNotificationVerificationData,
    val lostFactor: PhysicalFactor,
  ) : RecoveryInProgressData

  /**
   * Indicates that recovery has been initiated and Delay period has been finished. We are
   * ready to complete recovery.
   */
  sealed interface CompletingRecoveryData : RecoveryInProgressData {
    /**
     * Indicates that we are the stage where we need to complete rotating of authentication keys.
     */
    sealed interface RotatingAuthData : CompletingRecoveryData {
      /**
       * Indicates that delay period has passed and we are now ready to complete recovery with
       * f8e.
       *
       * @property startComplete confirm to complete recovery.
       * Should move to [RotatingAuthKeysWithF8eData].
       * @property cancel confirm to cancel recovery.
       */
      data class ReadyToCompleteRecoveryData(
        val physicalFactor: PhysicalFactor,
        val startComplete: () -> Unit,
        val cancel: () -> Unit,
      ) : RotatingAuthData

      /**
       * Awaiting for hardware to sign app generated challenge and CSEK.
       *
       * @property challengeToCompleteRecovery challenge generated by app to be signed by
       * hardware to later confirm recovery completion.
       * @property csek raw unsealed CSEK generated by app to be sealed by hardware. Will be
       * used to encrypt app backup once recovery is done.
       * @property addSignedChallengeAndCsek accept signed [challengeToCompleteRecovery] and sealed
       * [csek] from hardware. Should move to [RotatingAuthKeysWithF8eData].
       */
      data class AwaitingChallengeAndCsekSignedWithHardwareData(
        val nfcTransaction: NfcTransaction<SignedChallengeAndCsek>,
      ) : RotatingAuthData

      data class FailedToRotateAuthData(
        val onConfirm: () -> Unit,
      ) : RotatingAuthData

      /**
       * Indicates that we are rotating authentication keys f8e and are completing D&N recovery.
       * Once done, should move to [AwaitingChallengeAndCsekSignedWithHardwareData] as a first
       * step towards creating new spending keys.
       */
      data class RotatingAuthKeysWithF8eData(
        val physicalFactor: PhysicalFactor,
      ) : RotatingAuthData
    }

    /**
     * Indicates that we are the stage where we have completed D&N recovery with f8e and now are
     * creating new spending keys.
     */
    sealed interface CreatingSpendingKeysData : RotatingAuthData {
      /**
       * Awaiting hardware to provide hardware proof of possession (in this case, signed
       * f8e access token).
       *
       * @property addHwFactorProofOfPossession accept hardware proof of possession. Should move
       * to [CreatingSpendingKeysWithF8EData].
       */
      data class AwaitingHardwareProofOfPossessionData(
        val fullAccountId: FullAccountId,
        val keyboxConfig: KeyboxConfig,
        val appAuthKey: AppGlobalAuthPublicKey,
        val addHwFactorProofOfPossession: (HwFactorProofOfPossession) -> Unit,
        val rollback: () -> Unit,
      ) : CreatingSpendingKeysData

      /**
       * Creating new spending keys and waiting for response from f8e. Once created, should move
       * to [PerformingCloudBackupData].
       */
      data class CreatingSpendingKeysWithF8EData(
        val physicalFactor: PhysicalFactor,
      ) : CreatingSpendingKeysData

      data class FailedToCreateSpendingKeysData(
        val physicalFactor: PhysicalFactor,
        val onRetry: () -> Unit,
      ) : CreatingSpendingKeysData
    }

    /** Getting trusted contacts. */
    data object GettingTrustedContactsData : CompletingRecoveryData

    data class FailedGettingTrustedContactsData(
      val physicalFactor: PhysicalFactor,
      val retry: () -> Unit,
    ) : CompletingRecoveryData

    /**
     * Encrypting and backing up new keyset and app private keys. Once backup is finished,
     * should move to [PerformingSweepData].
     */
    data class PerformingCloudBackupData(
      val sealedCsek: SealedCsek,
      val keybox: Keybox,
      val trustedContacts: List<TrustedContact>,
      val onBackupFinished: () -> Unit,
      val onBackupFailed: () -> Unit,
    ) : CompletingRecoveryData

    data class FailedPerformingCloudBackupData(
      val physicalFactor: PhysicalFactor,
      val retry: () -> Unit,
    ) : CompletingRecoveryData

    /**
     * Performing sweep of funds into new spending keyset. Once sweep is done, recovery is fully
     * complete.
     */
    data class PerformingSweepData(
      val sweepData: SweepData,
      val rollback: () -> Unit,
    ) : CompletingRecoveryData

    data class ExitedPerformingSweepData(
      val physicalFactor: PhysicalFactor,
      val retry: () -> Unit,
    ) : CompletingRecoveryData
  }
}
